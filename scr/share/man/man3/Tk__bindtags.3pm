.\" Automatically generated by Pod::Man v1.37, Pod::Parser v1.14
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sh \" Subsection heading
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  | will give a
.\" real vertical bar.  \*(C+ will give a nicer C++.  Capital omega is used to
.\" do unbreakable dashes and therefore won't be available.  \*(C` and \*(C'
.\" expand to `' in nroff, nothing in troff, for use with C<>.
.tr \(*W-|\(bv\*(Tr
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.Sh), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.if \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.\"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.hy 0
.if n .na
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "bindtags 3"
.TH bindtags 3 "2007-11-17" "perl v5.8.5" "User Contributed Perl Documentation"
.SH "NAME"
Tk::bindtags \- Determine which bindings apply to a window, and order of evaluation
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
\&\fI$widget\fR\->\fBbindtags\fR([\fItagList\fR]);
.PP
\&\fI@tags\fR = \fI$widget\fR\->\fBbindtags\fR;
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
When a binding is created with the \fBbind\fR command, it is
associated either with a particular window such as \fI$widget\fR,
a class name such as \fBTk::Button\fR, the keyword \fBall\fR, or any
other string.
All of these forms are called \fIbinding tags\fR.
Each window has a list of binding tags that determine how
events are processed for the window.
When an event occurs in a window, it is applied to each of the
window's tags in order:  for each tag, the most specific binding
that matches the given tag and event is executed.
See the Tk::bind documentation for more information on the matching
process.
.PP
By default, each window has four binding tags consisting of the
the window's class name, name of the window, the name of the window's
nearest toplevel ancestor, and \fBall\fR, in that order.
Toplevel windows have only three tags by default, since the toplevel
name is the same as that of the window.
.PP
Note that this order is \fIdifferent\fR from order used by Tcl/Tk.
Tcl/Tk has the window ahead of the class name in the binding order.
This is because Tcl is procedural rather than object oriented and
the normal way for Tcl/Tk applications to override class bindings
is with an instance binding. However, with perl/Tk the normal way
to override a class binding is to derive a class. The perl/Tk order
causes instance bindings to execute after the class binding, and
so instance bind callbacks can make use of state changes (e.g. changes
to the selection) than the class bindings have made.
.PP
The \fBbindtags\fR command allows the binding tags for a window to be
read and modified.
.PP
If \fI$widget\fR\->\fBbindtags\fR is invoked without an argument, then the
current set of binding tags for \f(CW$widget\fR is returned as a list.
If the \fItagList\fR argument is specified to \fBbindtags\fR,
then it must be a reference to and array; the tags for \f(CW$widget\fR are changed
to the elements of the array. (A reference to an anonymous array can
be created by enclosin the elements in \fB[ ]\fR.)
The elements of \fItagList\fR may be arbitrary strings or widget objects,
if no window exists for an object at the time an event is processed,
then the tag is ignored for that event.
The order of the elements in \fItagList\fR determines the order in
which binding callbacks are executed in response to events.
For example, the command
.PP
.Vb 1
\& $b->bindtags([$b,ref($b),$b->toplevel,'all'])
.Ve
.PP
applies the Tcl/Tk binding order which binding callbacks will be
evaluated for a button (say) \fB$b\fR so that \fB$b\fR's instance bindings
are invoked first, following by bindings for \fB$b\fR's class, followed by
bindings for \fB$b\fR's toplevel, followed by '\fBall\fR' bindings.
.PP
If \fItagList\fR is an empty list i.e. \fB[]\fR, then the binding
tags for \f(CW$widget\fR are returned to the perl/Tk default state described above.
.PP
The \fBbindtags\fR command may be used to introduce arbitrary
additional binding tags for a window, or to remove standard tags.
For example, the command
.PP
.Vb 1
\& $b->bindtags(['TrickyButton',$b->toplevel,'all'])
.Ve
.PP
replaces the (say) \fBTk::Button\fR tag for \fB$b\fR with \fBTrickyButton\fR.
This means that the default widget bindings for buttons, which are
associated with the \fBTk::Button\fR tag, will no longer apply to \fB$b\fR,
but any bindings associated with \fBTrickyButton\fR (perhaps some
new button behavior) will apply.
.SH "BUGS"
.IX Header "BUGS"
The current mapping of the 'native' Tk behaviour of this method
i.e. returning a list but only accepting a reference to an array is
counter intuitive. The perl/Tk interface  may be tidied up, returning
a list is sensible so, most likely fix will be to allow a list to be
passed to /fIset/fR the bindtags.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Tk::bind
Tk::callbacks
.SH "KEYWORDS"
.IX Header "KEYWORDS"
binding, event, tag
