.\" Automatically generated by Pod::Man v1.37, Pod::Parser v1.14
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sh \" Subsection heading
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  | will give a
.\" real vertical bar.  \*(C+ will give a nicer C++.  Capital omega is used to
.\" do unbreakable dashes and therefore won't be available.  \*(C` and \*(C'
.\" expand to `' in nroff, nothing in troff, for use with C<>.
.tr \(*W-|\(bv\*(Tr
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.Sh), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.if \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.\"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.hy 0
.if n .na
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Tk::Trace 3"
.TH Tk::Trace 3 "2007-07-11" "Tk804.028" "perl/Tk Documentation"
.SH "NAME"
Tk::Trace \- emulate Tcl/Tk \fBtrace\fR functions.
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\& use Tk::Trace
.Ve
.PP
.Vb 4
\& $mw->traceVariable(\e$v, 'wru' => [\e&update_meter, $scale]);
\& %vinfo = $mw->traceVinfo(\e$v);
\& print "Trace info  :\en  ", join("\en  ", @{$vinfo{-legible}}), "\en";
\& $mw->traceVdelete(\e$v);
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This class module emulates the Tcl/Tk \fBtrace\fR family of commands by
binding subroutines of your devising to Perl variables using simple
\&\fBTie::Watch\fR features.
.PP
Callback format is patterned after the Perl/Tk scheme: supply either a
code reference, or, supply an array reference and pass the callback
code reference in the first element of the array, followed by callback
arguments.
.PP
User callbacks are passed these arguments:
.PP
.Vb 4
\& $_[0]        = undef for a scalar, index/key for array/hash
\& $_[1]        = variable's current (read), new (write), final (undef) value
\& $_[2]        = operation (r, w, or u)
\& $_[3 .. $#_] = optional user callback arguments
.Ve
.PP
As a Trace user, you have an important responsibility when writing your
callback, since you control the final value assigned to the variable.
A typical callback might look like:
.PP
.Vb 6
\& sub callback {
\&    my($index, $value, $op, @args) = @_;
\&    return if $op eq 'u';
\&    # .... code which uses $value ...
\&    return $value;     # variable's final value
\& }
.Ve
.PP
Note that the callback's return value becomes the variable's final value,
for either read or write traces.
.PP
For write operations, the variable is updated with its new value before
the callback is invoked.
.PP
Multiple read, write and undef callbacks can be attached to a variable,
which are invoked in reverse order of creation.
.SH "METHODS"
.IX Header "METHODS"
.IP "$mw\->traceVariable(varRef, op => callback);" 4
.IX Item "$mw->traceVariable(varRef, op => callback);"
\&\fBvarRef\fR is a reference to the scalar, array or hash variable you
wish to trace.  \fBop\fR is the trace operation, and can be any combination
of \fBr\fR for read, \fBw\fR for write, and \fBu\fR for undef.  \fBcallback\fR is a
standard Perl/Tk callback, and is invoked, depending upon the value of
\&\fBop\fR, whenever the variable is read, written, or destroyed.
.ie n .IP "%vinfo = $mw\->traceVinfo(varRef);" 4
.el .IP "%vinfo = \f(CW$mw\fR\->traceVinfo(varRef);" 4
.IX Item "%vinfo = $mw->traceVinfo(varRef);"
Returns a hash detailing the internals of the Trace object, with these
keys:
.Sp
.Vb 10
\& %vinfo = (
\&     -variable =>  varRef
\&     -debug    =>  '0'
\&     -shadow   =>  '1'
\&     -value    =>  'HELLO SCALAR'
\&     -destroy  =>  callback
\&     -fetch    =>  callback
\&     -store    =>  callback
\&     -legible  =>  above data formatted as a list of string, for printing
\& );
.Ve
.Sp
For array and hash Trace objects, the \fB\-value\fR key is replaced with a
\&\fB\-ptr\fR key which is a reference to the parallel array or hash.
Additionally, for an array or hash, there are key/value pairs for
all the variable specific callbacks.
.IP "$mw\->traceVdelete(\e$v);" 4
.IX Item "$mw->traceVdelete($v);"
Stop tracing the variable.
.SH "EXAMPLES"
.IX Header "EXAMPLES"
.Vb 1
\& # Trace a Scale's variable and move a meter in unison.
.Ve
.PP
.Vb 2
\& use Tk;
\& use Tk::widgets qw/Trace/;
.Ve
.PP
.Vb 6
\& $pi = 3.1415926;
\& $mw = MainWindow->new;
\& $c = $mw->Canvas( qw/-width 200 -height 110 -bd 2 -relief sunken/ )->grid;
\& $c->createLine( qw/100 100 10 100 -tag meter -arrow last -width 5/ );
\& $s = $mw->Scale( qw/-orient h -from 0 -to 100 -variable/ => \e$v )->grid;
\& $mw->Label( -text => 'Slide Me for 5 Seconds' )->grid;
.Ve
.PP
.Vb 1
\& $mw->traceVariable( \e$v, 'w' => [ \e&update_meter, $s ] );
.Ve
.PP
.Vb 6
\& $mw->after( 5000 => sub {
\&     print "Untrace time ...\en";
\&     %vinfo = $s->traceVinfo( \e$v );
\&     print "Watch info  :\en  ", join("\en  ", @{$vinfo{-legible}}), "\en";
\&     $c->traceVdelete( \e$v );
\& });
.Ve
.PP
.Vb 1
\& MainLoop;
.Ve
.PP
.Vb 11
\& sub update_meter {
\&     my( $index, $value, $op, @args ) = @_;
\&     return if $op eq 'u';
\&     $min = $s->cget( -from );
\&     $max = $s->cget( -to );
\&     $pos = $value / abs( $max - $min );
\&     $x = 100.0 - 90.0 * ( cos( $pos * $pi ) );
\&     $y = 100.0 - 90.0 * ( sin( $pos * $pi ) );
\&     $c->coords( qw/meter 100 100/, $x, $y );
\&     return $value;
\& }
.Ve
.PP
.Vb 1
\& # Predictive text entry.
.Ve
.PP
.Vb 3
\& use Tk;
\& use Tk::widgets qw/ LabEntry Trace /;
\& use strict;
.Ve
.PP
.Vb 1
\& my @words =  qw/radio television telephone turntable microphone/;
.Ve
.PP
.Vb 1
\& my $mw = MainWindow->new;
.Ve
.PP
.Vb 6
\& my $e = $mw->LabEntry(
\&     qw/ -label Thing -width 40 /,
\&     -labelPack    => [ qw/ -side left / ],
\&     -textvariable => \emy $thing,
\& );
\& my $t = $mw->Text( qw/ -height 10 -width 50 / );;
.Ve
.PP
.Vb 1
\& $t->pack( $e, qw/ -side top / );
.Ve
.PP
.Vb 2
\& $e->focus;
\& $e->traceVariable( \e$thing, 'w', [ \e&trace_thing, $e, $t ] );
.Ve
.PP
.Vb 9
\& foreach my $k ( 1 .. 12 ) {
\&     $e->bind( "<F${k}>" => [ \e&ins, $t, Ev('K') ] );
\& }
\& $e->bind( '<Return>' =>
\&           sub {
\&               print "$thing\en";
\&               $_[0]->delete( 0, 'end' );
\&           }
\& );
.Ve
.PP
.Vb 1
\& MainLoop;
.Ve
.PP
.Vb 1
\& sub trace_thing {
.Ve
.PP
.Vb 1
\&     my( $index, $value, $op, $e, $t ) = @_;
.Ve
.PP
.Vb 1
\&     return unless $value;
.Ve
.PP
.Vb 6
\&     $t->delete( qw/ 1.0 end / );
\&     foreach my $w ( @words ) {
\&         if ( $w =~ /^$value/ ) {
\&             $t->insert( 'end', "$w\en" );
\&         }
\&     }
.Ve
.PP
.Vb 1
\&     return $value;
.Ve
.PP
.Vb 1
\& } # end trace_thing
.Ve
.PP
.Vb 1
\& sub ins {
.Ve
.PP
.Vb 1
\&     my( $e, $t, $K ) = @_;
.Ve
.PP
.Vb 1
\&     my( $index ) = $K =~ /^F(\ed+)$/;
.Ve
.PP
.Vb 3
\&     $e->delete( 0, 'end' );
\&     $e->insert( 'end', $t->get( "$index.0", "$index.0 lineend" ) );
\&     $t->delete( qw/ 1.0 end / );
.Ve
.PP
.Vb 1
\& } # end ins
.Ve
.SH "HISTORY"
.IX Header "HISTORY"
.Vb 2
\& Stephen.O.Lidie@Lehigh.EDU, Lehigh University Computing Center, 2000/08/01
\& . Version 1.0, for Tk800.022.
.Ve
.PP
.Vb 3
\& sol0@Lehigh.EDU, Lehigh University Computing Center, 2003/09/22
\& . Version 1.1, for Tk804.025, add support for multiple traces of the same
\&   type on the same variable.
.Ve
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
Copyright (C) 2000 \- 2003 Stephen O. Lidie. All rights reserved.
.PP
This program is free software; you can redistribute it and/or modify it under
the same terms as Perl itself.
